-- Generated by GithubCopilot
-- Model: Sync dbt test results to DIF DQ_LOG via Elementary
-- Provides enhanced observability by combining dbt-artifacts with elementary

{{ config(
    materialized='incremental',
    unique_key='log_key',
    schema='DIF_OBSERVABILITY',
    tags=['dif_v15', 'observability']
) }}

{# 
   This model reads from elementary/dbt-artifacts test result tables
   and enriches them with DIF-specific metadata for unified reporting.
#}

{% set dif_db = var('dif_database', 'DB_GOVERNANCE') %}

WITH elementary_results AS (
  -- Read from elementary test results if available
  {% if adapter.check_schema_exists(dif_db, 'ELEMENTARY') %}
  SELECT
    test_unique_id AS unique_id,
    test_name,
    test_short_name,
    status,
    failures AS failure_count,
    detected_at AS execution_time,
    test_params_json,
    model_metadata_json
  FROM {{ dif_db }}.ELEMENTARY.elementary_test_results
  WHERE detected_at >= DATEADD('day', -7, CURRENT_TIMESTAMP())
  {% else %}
  -- Fallback if elementary not configured
  SELECT
    CAST(NULL AS VARCHAR) AS unique_id,
    CAST(NULL AS VARCHAR) AS test_name,
    CAST(NULL AS VARCHAR) AS test_short_name,
    CAST(NULL AS VARCHAR) AS status,
    CAST(NULL AS NUMBER) AS failure_count,
    CAST(NULL AS TIMESTAMP_LTZ) AS execution_time,
    CAST(NULL AS VARIANT) AS test_params_json,
    CAST(NULL AS VARIANT) AS model_metadata_json
  WHERE 1=0
  {% endif %}
),

dbt_artifacts_results AS (
  -- Read from dbt_artifacts test results if available
  {% if adapter.check_schema_exists(dif_db, 'DBT_ARTIFACTS') %}
  SELECT
    unique_id,
    name AS test_name,
    status,
    failures AS failure_count,
    message AS error_message,
    execute_started_at,
    execute_completed_at,
    invocation_id AS run_id
  FROM {{ dif_db }}.DBT_ARTIFACTS.fct_dbt_test_results
  WHERE execute_started_at >= DATEADD('day', -7, CURRENT_TIMESTAMP())
  {% else %}
  SELECT
    CAST(NULL AS VARCHAR) AS unique_id,
    CAST(NULL AS VARCHAR) AS test_name,
    CAST(NULL AS VARCHAR) AS status,
    CAST(NULL AS NUMBER) AS failure_count,
    CAST(NULL AS VARCHAR) AS error_message,
    CAST(NULL AS TIMESTAMP_LTZ) AS execute_started_at,
    CAST(NULL AS TIMESTAMP_LTZ) AS execute_completed_at,
    CAST(NULL AS VARCHAR) AS run_id
  WHERE 1=0
  {% endif %}
),

unified_results AS (
  -- Combine and deduplicate results from both sources
  SELECT
    COALESCE(da.unique_id, el.unique_id) AS unique_id,
    COALESCE(da.test_name, el.test_name) AS test_name,
    COALESCE(da.status, el.status) AS status,
    COALESCE(da.failure_count, el.failure_count) AS failure_count,
    da.error_message,
    COALESCE(da.execute_started_at, el.execution_time) AS start_time,
    COALESCE(da.execute_completed_at, el.execution_time) AS end_time,
    da.run_id
  FROM dbt_artifacts_results da
  FULL OUTER JOIN elementary_results el ON da.unique_id = el.unique_id
)

SELECT
  MD5(CONCAT(COALESCE(run_id, ''), unique_id, CAST(start_time AS VARCHAR))) AS log_key,
  run_id,
  -- Extract RULE_ID from test name: look for 'RULE_' prefix pattern
  CASE
    WHEN UPPER(test_name) LIKE '%RULE_%' THEN
      REGEXP_SUBSTR(UPPER(test_name), 'RULE_[A-Z]+_[0-9]+')
    ELSE
      'DBT_' || LEFT(UPPER(test_name), 100)
  END AS rule_id,
  -- Map test name to DIF rule type via keyword matching
  CASE
    WHEN LOWER(test_name) LIKE '%not_null%' OR LOWER(test_name) LIKE '%null_check%' THEN 'NULL_CHECK'
    WHEN LOWER(test_name) LIKE '%relationship%' OR LOWER(test_name) LIKE '%referential%' THEN 'REFERENTIAL_INTEGRITY'
    WHEN LOWER(test_name) LIKE '%sum_match%' THEN 'SUM_MATCH'
    WHEN LOWER(test_name) LIKE '%unique%' OR LOWER(test_name) LIKE '%duplicate%' THEN 'DUPLICATE_CHECK'
    WHEN LOWER(test_name) LIKE '%accepted_values%' OR LOWER(test_name) LIKE '%value_range%' THEN 'VALUE_RANGE'
    WHEN LOWER(test_name) LIKE '%row_count%' THEN 'ROW_COUNT'
    WHEN LOWER(test_name) LIKE '%freshness%' THEN 'DATA_FRESHNESS'
    ELSE 'CUSTOM_SQL'
  END AS rule_type,
  'DBT' AS engine,
  -- Map dbt status to DIF status
  CASE
    WHEN LOWER(status) = 'pass' THEN 'PASS'
    WHEN LOWER(status) = 'fail' THEN 'FAIL'
    WHEN LOWER(status) = 'warn' THEN 'WARN'
    WHEN LOWER(status) = 'error' THEN 'ERROR'
    WHEN LOWER(status) = 'skipped' THEN 'SKIP'
    ELSE 'ERROR'
  END AS status,
  failure_count AS actual_value,
  error_message,
  start_time,
  end_time,
  CURRENT_TIMESTAMP() AS synced_at
FROM unified_results
WHERE unique_id IS NOT NULL

{% if is_incremental() %}
  AND start_time > (SELECT MAX(start_time) FROM {{ this }})
{% endif %}
